# Store all the data in the volumes
volumes:
  npm_storage:
  npm_letsencrypt:
  n8n_storage:
  cloudflared_storage:
  postgres_storage:
  redis_storage:
  ollama_storage:
  qdrant_storage:

# Create a network for the services to communicate with each other
networks:
  n8n-network:
    driver: bridge

# Create the services
services:
  # Handle the SSL certificates and the reverse proxy for the n8n instance
  nginx-proxy-manager:
    image: jc21/nginx-proxy-manager:latest # Use the latest nginx-proxy-manager image
    hostname: nginx-proxy-manager # Set the hostname for the service
    container_name: nginx-proxy-manager # Set the container name
    restart: always # Restart the service if it crashes
    ports:
      - "80:80" # HTTP
      - "443:443" # HTTPS
      - "81:81" # Admin panel
    volumes:
      - npm_storage:/data # Store the data for the NPM instance
      - npm_letsencrypt:/etc/letsencrypt # Store the SSL certificates
    environment:
      - DISABLE_IPV6=true
      - TZ=${TZ} # Set the timezone
    networks:
      - n8n-network

  # Handle the cloudflared tunnel
  cloudflared:
    image: cloudflare/cloudflared:latest # Use the latest cloudflared image
    hostname: cloudflared # Set the hostname for the service
    container_name: cloudflared # Set the container name
    restart: unless-stopped # Restart the service if it crashes
    command: tunnel --no-autoupdate run --token ${CLOUDFLARED_TUNNEL_TOKEN} # Run the cloudflared tunnel
    volumes:
      - cloudflared_storage:/etc/cloudflared # Store the cloudflared configuration
    networks:
      - n8n-network

  # Handle the postgres database
  postgres:
    image: postgres:16 # Use the latest postgres image
    hostname: postgres # Set the hostname for the service
    container_name: postgres # Set the container name
    restart: unless-stopped # Restart the service if it crashes
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_NON_ROOT_USER=${POSTGRES_NON_ROOT_USER}
      - POSTGRES_NON_ROOT_PASSWORD=${POSTGRES_NON_ROOT_PASSWORD}
    volumes:
      - postgres_storage:/var/lib/postgresql/data # Store the postgres data
      - ./init-data.sh:/docker-entrypoint-initdb.d/init-data.sh # Run the init-data.sh script
    networks:
      - n8n-network
    healthcheck: # Check if the postgres service is healthy
      test:
        [
          "CMD-SHELL",
          "pg_isready -h localhost -U ${POSTGRES_USER} -d ${POSTGRES_DB}",
        ]
      interval: 5s
      timeout: 5s
      retries: 10

  # Handle the redis database
  redis:
    image: redis:latest # Use the latest redis image
    hostname: redis # Set the hostname for the service
    container_name: redis # Set the container name
    restart: unless-stopped # Restart the service if it crashes
    volumes:
      - redis_storage:/data # Store the redis data
    networks:
      - n8n-network
    healthcheck: # Check if the redis service is healthy
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 5s
      retries: 10

  # Handle the qdrant database
  qdrant:
    image: qdrant/qdrant:latest # Use the latest qdrant image
    hostname: qdrant # Set the hostname for the service
    container_name: qdrant # Set the container name
    restart: unless-stopped # Restart the service if it crashes
    volumes:
      - qdrant_storage:/qdrant/storage
    networks:
      - n8n-network

  # Handle the ollama model server
  ollama:
    # Use `ollama/ollama:latest` for CPU, or `ollama/ollama:rocm` for AMD GPUs.
    # For NVIDIA, use the `deploy` section below.
    image: ollama/ollama:latest
    container_name: ollama
    restart: unless-stopped
    volumes:
      - ollama_storage:/root/.ollama
    networks:
      - n8n-network
    healthcheck:
      test: ["CMD", "ollama", "list"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    # For NVIDIA GPUs, uncomment the following:
    # deploy:
    #   resources:
    #     reservations:
    #       devices:
    #         - driver: nvidia
    #           count: all
    #           capabilities: [gpu]
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all
              capabilities: [gpu]
    # For AMD GPUs on Linux, uncomment the following:
    # devices:
    #   - "/dev/kfd"
    #   - "/dev/dri"

  # Handle the init-ollama service
  # This service will pull the llama3 model when you first start the stack.
  # You can change 'llama3.2' to another model if you prefer.
  init-ollama:
    image: ollama/ollama:latest
    container_name: init-ollama
    networks:
      - n8n-network
    volumes:
      - ollama_storage:/root/.ollama
    entrypoint: /bin/sh
    command:
      - "-c"
      - |
        echo "Waiting for Ollama server to be ready..."
        until OLLAMA_HOST=http://ollama:11434 ollama list > /dev/null 2>&1; do
          echo "Waiting for Ollama server..."
          sleep 5
        done
        echo "Ollama server is ready, pulling models..."
        OLLAMA_HOST=http://ollama:11434 ollama pull llama3.2
        echo "Models pulled successfully"
    depends_on:
      ollama:
        condition: service_healthy

  # Handle the n8n-import service
  n8n-import:
    image: docker.n8n.io/n8nio/n8n:latest # Use the latest n8n image
    hostname: n8n-import # Set the hostname for the service
    container_name: n8n-import # Set the container name
    restart: "no" # Do not restart the service if it crashes
    volumes:
      - ./n8n/import:/import
      - n8n_storage:/home/node/.n8n
      # - ./import-loop.sh:/scripts/import-loop.sh:ro
    networks:
      - n8n-network
    entrypoint: /bin/sh
    command: 
      - "-c"
      - |
        if [ "${RUN_IMPORT_ON_STARTUP:-false}" = "true" ]; then
          echo "RUN_IMPORT_ON_STARTUP is true. Running import..."
          n8n import:credentials --separate --input=/import/credentials && n8n import:workflow --separate --input=/import/workflows
        else
          echo "RUN_IMPORT_ON_STARTUP is not true. Skipping import."
        fi
    # command: ["/scripts/import-loop.sh"]
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_USER=${POSTGRES_NON_ROOT_USER}
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_NON_ROOT_PASSWORD}
      - DB_POSTGRESDB_DATABASE=${POSTGRES_DB}
      - DB_POSTGRESDB_PORT=5432
      - QUEUE_BULL_REDIS_HOST=redis
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - N8N_USER_MANAGEMENT_JWT_SECRET=${N8N_USER_MANAGEMENT_JWT_SECRET}
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - N8N_RUNNERS_ENABLED=true
      - RUN_IMPORT_ON_STARTUP=${RUN_IMPORT_ON_STARTUP:-false}

  # Handle the n8n-export service
  n8n-export:
    image: docker.n8n.io/n8nio/n8n:latest # Use the latest n8n image
    hostname: n8n-export # Set the hostname for the service
    container_name: n8n-export # Set the container name
    restart: "no" # Do not restart the service if it crashes
    networks:
      - n8n-network
    volumes:
      - ./n8n/backup:/backup
      - n8n_storage:/home/node/.n8n
    entrypoint: /bin/sh
    command:
      - "-c"
      - |
        if [ "${RUN_BACKUP_ON_STARTUP:-false}" = "true" ]; then
          echo "RUN_BACKUP_ON_STARTUP is true. Running export..."
          n8n export:credentials --backup --output=/backup/credentials && n8n export:workflow --backup --output=/backup/workflows || true
        else
          echo "RUN_BACKUP_ON_STARTUP is not true. Skipping export."
        fi
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      n8n-import:
        condition: service_completed_successfully
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_USER=${POSTGRES_NON_ROOT_USER}
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_NON_ROOT_PASSWORD}
      - DB_POSTGRESDB_DATABASE=${POSTGRES_DB}
      - DB_POSTGRESDB_PORT=5432
      - QUEUE_BULL_REDIS_HOST=redis
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - N8N_USER_MANAGEMENT_JWT_SECRET=${N8N_USER_MANAGEMENT_JWT_SECRET}
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - N8N_RUNNERS_ENABLED=true
      - RUN_BACKUP_ON_STARTUP=${RUN_BACKUP_ON_STARTUP:-false}

  n8n:
    image: docker.n8n.io/n8nio/n8n:latest
    hostname: n8n # Set the hostname for the service
    container_name: n8n # Set the container name
    restart: unless-stopped # Restart the service if it crashes
    environment:
      - WEBHOOK_URL=https://${URL}/ # Set the webhook URL
      - N8N_PROTOCOL=https # Set the protocol
      - N8N_HOST=${URL} # Set the host
      - GENERIC_TIMEZONE=${TZ} # Set the timezone
      - N8N_TRUST_PROXY=true # Trust the proxy (nginx-proxy-manager in this case)
      - N8N_PROXY_HOPS=2 # Number of proxies in front of the n8n instance (nginx-proxy-manager and cloudflared)
      - EXECUTIONS_MODE=queue # Set the executions mode
      - QUEUE_BULL_REDIS_HOST=redis # Set the redis host
      - QUEUE_HEALTH_CHECK_ACTIVE=true # Set the queue health check active    
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true # Routes manual “Run” actions to queue workers, keeping the main UI container free
      - DB_TYPE=postgresdb # Set the database type
      - DB_POSTGRESDB_HOST=postgres # Set the postgres host
      - DB_POSTGRESDB_USER=${POSTGRES_NON_ROOT_USER}
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_NON_ROOT_PASSWORD}
      - DB_POSTGRESDB_DATABASE=${POSTGRES_DB}
      - DB_POSTGRESDB_PORT=5432
      - N8N_DIAGNOSTICS_ENABLED=false # Toggle anonymous telemetry to n8n (disable = no usage stats sent)
      - N8N_PERSONALIZATION_ENABLED=false # Enables/Disables onboarding tips & template banners in the UI
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}  # Key used to encrypt credentials stored in the DB
      - N8N_USER_MANAGEMENT_JWT_SECRET=${N8N_USER_MANAGEMENT_JWT_SECRET} # Signs JWTs for user sessions / role-based access
      - OLLAMA_HOST=ollama:11434
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true # Forces 0600 permissions on ~/.n8n config for extra security
      - N8N_RUNNERS_ENABLED=true  # Turns on new task-runner workers for scalable queue execution
    volumes:
      - n8n_storage:/home/node/.n8n
      - ./n8n/backup:/backup
      - ./n8n/import:/import
      - ./n8n/import/credentials:/import/credentials
      - ./n8n/import/workflows:/import/workflows
    networks:
      - n8n-network
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      n8n-import:
        condition: service_completed_successfully
      n8n-export:
        condition: service_completed_successfully

  n8n-worker:
    image: docker.n8n.io/n8nio/n8n:latest
    hostname: n8n-worker
    container_name: n8n-worker
    command: worker
    restart: unless-stopped
    environment:
      - GENERIC_TIMEZONE=${TZ}
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_HEALTH_CHECK_ACTIVE=true
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_USER=${POSTGRES_NON_ROOT_USER}
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_NON_ROOT_PASSWORD}
      - DB_POSTGRESDB_DATABASE=${POSTGRES_DB}
      - DB_POSTGRESDB_PORT=5432
      - N8N_DIAGNOSTICS_ENABLED=false
      - N8N_PERSONALIZATION_ENABLED=false
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - N8N_USER_MANAGEMENT_JWT_SECRET=${N8N_USER_MANAGEMENT_JWT_SECRET}
      - OLLAMA_HOST=ollama:11434
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - N8N_RUNNERS_ENABLED=true
    volumes:
      - n8n_storage:/home/node/.n8n
    networks:
      - n8n-network
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      n8n-import:
        condition: service_completed_successfully
      n8n-export:
        condition: service_completed_successfully
